
import typing
import botocore.session
import aws_meta
from botocore.model import *
from botocore.client import BaseClient
from datetime import datetime
import boto3


class Map(dict):
    pass
    
    
# noinspection PyPep8Naming
class dynamodb_client_type(BaseClient):
    def batch_get_item(self, RequestItems: Map, ReturnConsumedCapacity: str = None): ...
    def batch_write_item(self, RequestItems: Map, ReturnConsumedCapacity: str = None, ReturnItemCollectionMetrics: str = None): ...
    def create_backup(self, TableName: str, BackupName: str): ...
    def create_global_table(self, GlobalTableName: str, ReplicationGroup: list): ...
    def create_table(self, AttributeDefinitions: list, TableName: str, KeySchema: list, LocalSecondaryIndexes: list = None, GlobalSecondaryIndexes: list = None, BillingMode: str = None, ProvisionedThroughput: dict = None, StreamSpecification: dict = None, SSESpecification: dict = None, Tags: list = None): ...
    def delete_backup(self, BackupArn: str): ...
    def delete_item(self, TableName: str, Key: Map, Expected: Map = None, ConditionalOperator: str = None, ReturnValues: str = None, ReturnConsumedCapacity: str = None, ReturnItemCollectionMetrics: str = None, ConditionExpression: str = None, ExpressionAttributeNames: Map = None, ExpressionAttributeValues: Map = None): ...
    def delete_table(self, TableName: str): ...
    def describe_backup(self, BackupArn: str): ...
    def describe_continuous_backups(self, TableName: str): ...
    def describe_endpoints(self): ...
    def describe_global_table(self, GlobalTableName: str): ...
    def describe_global_table_settings(self, GlobalTableName: str): ...
    def describe_limits(self): ...
    def describe_table(self, TableName: str): ...
    def describe_time_to_live(self, TableName: str): ...
    def get_item(self, TableName: str, Key: Map, AttributesToGet: list = None, ConsistentRead: bool = None, ReturnConsumedCapacity: str = None, ProjectionExpression: str = None, ExpressionAttributeNames: Map = None): ...
    def list_backups(self, TableName: str = None, Limit: int = None, TimeRangeLowerBound: datetime = None, TimeRangeUpperBound: datetime = None, ExclusiveStartBackupArn: str = None, BackupType: str = None): ...
    def list_global_tables(self, ExclusiveStartGlobalTableName: str = None, Limit: int = None, RegionName: str = None): ...
    def list_tables(self, ExclusiveStartTableName: str = None, Limit: int = None): ...
    def list_tags_of_resource(self, ResourceArn: str, NextToken: str = None): ...
    def put_item(self, TableName: str, Item: Map, Expected: Map = None, ReturnValues: str = None, ReturnConsumedCapacity: str = None, ReturnItemCollectionMetrics: str = None, ConditionalOperator: str = None, ConditionExpression: str = None, ExpressionAttributeNames: Map = None, ExpressionAttributeValues: Map = None): ...
    def query(self, TableName: str, IndexName: str = None, Select: str = None, AttributesToGet: list = None, Limit: int = None, ConsistentRead: bool = None, KeyConditions: Map = None, QueryFilter: Map = None, ConditionalOperator: str = None, ScanIndexForward: bool = None, ExclusiveStartKey: Map = None, ReturnConsumedCapacity: str = None, ProjectionExpression: str = None, FilterExpression: str = None, KeyConditionExpression: str = None, ExpressionAttributeNames: Map = None, ExpressionAttributeValues: Map = None): ...
    def restore_table_from_backup(self, TargetTableName: str, BackupArn: str): ...
    def restore_table_to_point_in_time(self, SourceTableName: str, TargetTableName: str, UseLatestRestorableTime: bool = None, RestoreDateTime: datetime = None): ...
    def scan(self, TableName: str, IndexName: str = None, AttributesToGet: list = None, Limit: int = None, Select: str = None, ScanFilter: Map = None, ConditionalOperator: str = None, ExclusiveStartKey: Map = None, ReturnConsumedCapacity: str = None, TotalSegments: int = None, Segment: int = None, ProjectionExpression: str = None, FilterExpression: str = None, ExpressionAttributeNames: Map = None, ExpressionAttributeValues: Map = None, ConsistentRead: bool = None): ...
    def tag_resource(self, ResourceArn: str, Tags: list): ...
    def transact_get_items(self, TransactItems: list, ReturnConsumedCapacity: str = None): ...
    def transact_write_items(self, TransactItems: list, ReturnConsumedCapacity: str = None, ReturnItemCollectionMetrics: str = None, ClientRequestToken: str = None): ...
    def untag_resource(self, ResourceArn: str, TagKeys: list): ...
    def update_continuous_backups(self, TableName: str, PointInTimeRecoverySpecification: dict): ...
    def update_global_table(self, GlobalTableName: str, ReplicaUpdates: list): ...
    def update_global_table_settings(self, GlobalTableName: str, GlobalTableBillingMode: str = None, GlobalTableProvisionedWriteCapacityUnits: int = None, GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: dict = None, GlobalTableGlobalSecondaryIndexSettingsUpdate: list = None, ReplicaSettingsUpdate: list = None): ...
    def update_item(self, TableName: str, Key: Map, AttributeUpdates: Map = None, Expected: Map = None, ConditionalOperator: str = None, ReturnValues: str = None, ReturnConsumedCapacity: str = None, ReturnItemCollectionMetrics: str = None, UpdateExpression: str = None, ConditionExpression: str = None, ExpressionAttributeNames: Map = None, ExpressionAttributeValues: Map = None): ...
    def update_table(self, TableName: str, AttributeDefinitions: list = None, BillingMode: str = None, ProvisionedThroughput: dict = None, GlobalSecondaryIndexUpdates: list = None, StreamSpecification: dict = None, SSESpecification: dict = None): ...
    def update_time_to_live(self, TableName: str, TimeToLiveSpecification: dict): ...
    pass

